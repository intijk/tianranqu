(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{408:function(t,a,s){"use strict";s.r(a);var n=s(10),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"纹理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#纹理"}},[t._v("#")]),t._v(" 纹理")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/",target:"_blank",rel:"noopener noreferrer"}},[t._v("文档链接"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("有时候问题就是越看越多。。。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("Fragement 是光栅化以后逐像素的操作吗？ 从这个答案看来是的：\nhttps://zhuanlan.zhihu.com/p/56693625")])]),t._v(" "),s("li",[s("p",[t._v("Fragment Shader里的texture()函数是一个采样的功能，从ourTexture采样TexCoord得到一个像素值，这其中会使用filter功能，但是它是怎么判定自己的mipmap的级别的呢?")])])]),t._v(" "),s("p",[t._v("--")]),t._v(" "),s("div",{staticClass:"language-glsl extra-class"},[s("pre",{pre:!0,attrs:{class:"language-glsl"}},[s("code",[t._v("    FragColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ourTexture"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" TexCoord"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("TexCoord是一个浮点数呀，仅凭一个图像指针ourTexture和一个浮点数坐标TexCoord是判断不了缩放了的呀。那么必然还有其它的隐藏判断信息，比如光栅化的时候，得到的这个像素相对于整个texture的大小的情况，我猜是因为光栅化做过了，所以fragment相对于ourTexture的大小这个信息是一个隐藏变量，这个隐藏变量在texture()里被调用了。从而能够确定自己现在是在做maxify还是minify，从而调用了相应的filter模式。")]),t._v(" "),s("p",[t._v("glGenerateMipmap 我猜是像图像金字塔一样的，生成一个多级的金字塔多张图片，然后储存起来以备后用。")]),t._v(" "),s("p",[t._v("Texture 的 0 号是被默认启用的。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glActiveTexture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_TEXTURE0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("glTexImage2D是真正进行内存到显存图像拷贝操作的API")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glTexImage2D")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_TEXTURE_2D"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_RGB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" width"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" height"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_RGB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_UNSIGNED_BYTE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("glUniform1i可以把fragment shader里的sampler2D变量绑定在一个纹理单元上，采样器的背后，指向了纹理单元的buffer内容。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glUniform1i")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("glGetUniformLocation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ourShader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"texture1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 手动设置")]),t._v("\n")])])]),s("p",[t._v("示例中的并不能给两个不同的纹理单元不同的采样坐标，如果想要传入不同的坐标，需要在VAP里的数据里再加入一组不同的st。")]),t._v(" "),s("p",[t._v("通过修改vbo里的st数据，或者修改texture()的采样顶点都可以达到缩放图片的目的。")])])}),[],!1,null,null,null);a.default=e.exports}}]);