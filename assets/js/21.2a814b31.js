(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{410:function(t,e,a){"use strict";a.r(e);var s=a(10),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("设置 "),a("code",[t._v("glClearColor(1.0f, 0.5f, 1.0f, 1.0f);")])]),t._v(" "),a("p",[t._v("渲染 "),a("code",[t._v("glClear(GL_COLOR_BUFFER_BIT);")])]),t._v(" "),a("p",[t._v("而且如果是glfw的话，必须要有: "),a("code",[t._v("glfwSwapBuffers(window);")])]),t._v(" "),a("p",[t._v("glfw提供了一套默认的包含OpenGL ES的规则, 注意，#define一定要放在include前面!!!")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[t._v("GLFW_INCLUDE_ES3")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<GLFW/glfw3.h>")])]),t._v("\n")])])]),a("p",[t._v("VertexAttirbPointer提供的是对vbo的解析，这本身就会形成一个vertex stream，按第二个参数，形成不同大小的点。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);\n")])])]),a("p",[t._v("第二个参数可以是1,2,3,4，分别对应以下情况")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("EBO下标:   0,        1,        2,...\n1:       (x),      (x),      (x),...\n2:     (x,y),    (x,y),    (x,y),...\n3:   (x,y,z),  (x,y,z),  (x,y,z),...\n4: (x,y,z,w),(x,y,z,w),(x,y,z,w),...\n")])])]),a("p",[t._v("所以如果有EBO的话，和VertexAttirb肯定是配合使用的，ebo的值代表了vertex stream里各个点的序号。")]),t._v(" "),a("p",[t._v("glDrawElements的第二个参数是count，这个count是index的count，那一个index对应一个点，自然这个count就是要绘制的点的数量了，这样的VBO(EBO)形成了一个新的流。")]),t._v(" "),a("p",[t._v("所以构造流的方式更多是这样的 VBO~VAP(EBO)")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("glDrawElements")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GL_TRIANGLES"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" GL_UNSIGNED_INT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),a("h2",{attrs:{id:"特效比如阴影是如何绘制的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特效比如阴影是如何绘制的？"}},[t._v("#")]),t._v(" 特效比如阴影是如何绘制的？")]),t._v(" "),a("p",[t._v("像绘制3d物体的时候，物体已经绘制上去了，然后再绘制的时候，深度缓冲会保证后面的绘制不会出现层次问题。那么阴影是如何绘制的呢？我理解的绘制过程其实是多个buffer参与，然后对buffer进行一个混合的过程，但是glDraw的时候却要直接上屏了，那么很多不同的glDraw的时候，岂不就乱了吗，比如我一开始绘制了一个无阴影的，第二次绘制能再添阴影上去吗？这不就破坏了fs的结构吗，两个东西都给出片段颜色？")]),t._v(" "),a("h2",{attrs:{id:"vscode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vscode"}},[t._v("#")]),t._v(" vscode")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('        "C_Cpp.errorSquiggles": "Disabled",\n        "prettier.tabWidth": 4,\n        "[cpp]": {\n            "editor.detectIndentation": false,\n            "editor.tabSize": 4,\n            //用clang format 来设置缩进\n            "editor.defaultFormatter": "xaver.clang-format" \n        }\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('        "C_Cpp.errorSquiggles": "Disabled",\n        "prettier.tabWidth": 4,\n        "[cpp]": {\n            "editor.detectIndentation": false,\n            "editor.tabSize": 4,\n            //用clang format 来设置缩进\n            "editor.defaultFormatter": "xaver.clang-format" \n        }\n')])])]),a("p",[t._v("vscode的缩进总是不尽人意，所以在workspace里设置了相应的参数:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('        "C_Cpp.errorSquiggles": "Disabled",\n        "prettier.tabWidth": 4,\n        "[cpp]": {\n            "editor.detectIndentation": false,\n            "editor.tabSize": 4,\n            //用clang format 来设置缩进\n            "editor.defaultFormatter": "xaver.clang-format" \n        }\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("clang-format -style=llvm -dump-config > .clang-format\n然后修改其中的：\nBreakBeforeBraces: Linux # Linux风格就是大括号只在函数时新起一行\nIndentWidth: 4 # 虽然很多项目里都是2， 但是有些课程，作业，例子，等我接触到的东西都基本上用的4\nColumnLimit: 200 # 我不喜欢很快的就折行，即使是出于code review目的，编辑器也是可以折行的，有时候长行是必要的\nAllowShortFunctionsOnASingleLine: None # 因为我允许很长的行，所以有的函数被折成一行了，不想这样，所以设置这个选项为None\n")])])]),a("h2",{attrs:{id:"一些经验教训"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些经验教训"}},[t._v("#")]),t._v(" 一些经验教训")]),t._v(" "),a("ul",[a("li",[t._v("计算在不在三角形内部，是要cross(p-v0, v1-v0), 而不是cross(p, v1-v0)，错误的方法得到的判断是点永远在三角形外。")]),t._v(" "),a("li",[t._v("不要用浮点数去乘以宽度计算像素位置，会错行的！")]),t._v(" "),a("li",[t._v("因为一个简单的下标计算，和一个float写成了int，浪费了很多debug时间。要多看自己刚写的，避免出问题。")]),t._v(" "),a("li",[t._v("调试方法，可以把光栅化的图弄的非常小，然后只研究那几个像素，很快就能发现问题")])])])}),[],!1,null,null,null);e.default=r.exports}}]);